# Bruker 2-Photon Video Utils
# Jeremy Delahanty May 2021
# Harvesters written by Kazunari Kudo
# https://github.com/genicam/harvesters

###############################################################################
# Import Packages
###############################################################################

# Teledyne DALSA Genie Nano Interface: Harvesters
from harvesters.core import Harvester

# Import OpenCV2 to write images/videos to file + previews
import cv2

# Static cti file location
cti_filepath = "C:/Program Files/MATRIX VISION/mvIMPACT Acquire/bin/x64/mvGENTLProducer.cti"


###############################################################################
# Video Exception Creation
###############################################################################


class FrameDropped(Exception):
    """Error raised if packet is lost during recording."""


###############################################################################
# Camera Control
###############################################################################

# -----------------------------------------------------------------------------
# Initiate Preview Camera
# -----------------------------------------------------------------------------


def init_camera_preview():
    """
    Creates, configures, describes, and starts harvesters camera object in
    preview setting.

    Initializes harvester camera, sets camera properties appropriate for
    preview, gathers the camera's width and height in pixels, and starts
    video acquisition.

    Args:
        None

    Returns:
        Two objects:
            1. Harvester object
            2. Camera object

        Two variables:
            1. Camera's height (pixels)
            2. Camera's width (pixels)

    """

    # Create camera variable as None type
    camera = None

    # Create harvester object as h
    h = Harvester()

    # Give path to GENTL producer
    cti_file = cti_filepath

    # Add GENTL producer to Harvester object
    h.add_file(cti_file)

    # Update Harvester object
    h.update()

    # Print device list to make sure camera is present
    # TODO: Raise an error if no camera is detected
    print("Connected to Camera: \n", h.device_info_list)

    # Grab Camera, Change Settings
    # Create image_acquirer object for Harvester, grab first (only) device
    camera = h.create_image_acquirer(0)

    # Gather node map to camera properties
    n = camera.remote_device.node_map

    # Save camera width and height parameters
    width = n.Width.value
    height = n.Height.value

    # Change camera properties for continuous recording, no triggers needed
    n.AcquisitionMode.value = "Continuous"
    n.TriggerMode.value = "Off"

    # Show user the preview acquisition mode
    print("Preview Mode:", n.AcquisitionMode.value)

    # Start the acquisition
    print("Starting Preview")
    camera.start_acquisition()

    # Return harvester, camera, and width/height in pixels of camera
    return h, camera, width, height


# -----------------------------------------------------------------------------
# Capture Preview of Camera
# -----------------------------------------------------------------------------


def capture_preview():
    """
    Capture frames generated by camera object and display them in preview mode.

    Takes values from init_camera_preview() to capture images delivered by
    camera buffer, reshapes the image to appropriate height and width, and
    finally displays the image to an opencv window. When user hits the 'Esc'
    key, the window closes and the camera object is destroyed.

    Args:
        None

    Returns:
        None
    """

    h, camera, width, height = init_camera_preview()
    preview_status = True
    print("To stop preview, hit 'Esc' key")
    while preview_status is True:
        try:
            with camera.fetch_buffer() as buffer:
                # Define frame content with buffer.payload
                content = buffer.payload.components[0].data.reshape(height,
                                                                    width)

                # Provide preview for camera contents:
                cv2.imshow("Preview", content)
                c = cv2.waitKey(1) % 0x100
                if c == 27:
                    preview_status = False
        except:
            print("Frame Dropped/Packet Loss")
            pass

    cv2.destroyAllWindows()

    # Shutdown the camera
    shutdown_camera(camera, h)


# -----------------------------------------------------------------------------
# Initialize Camera for Recording
# -----------------------------------------------------------------------------


# TODO: Make init_camera_recording_behavior and
# init_camera_recording_microscopy for better flexibility

def init_camera_recording(behavior_flag):
    """
    Creates, configures, describes, and starts harvesters camera object in
    recording setting.

    Initializes harvester camera, sets camera properties appropriate for
    behavior recording, gathers the camera's width and height in pixels, and
    starts video acquisition.

    Args:
        behavior_flag:
            Flag obtained from bruker_control.py argparser.  If True,
            a continous recording is obtained without relying on TTL triggers
            fromt the microscope. If False, the recording will use TTL
            triggers from the microscope.

    Returns:
        Two objects:
            1. Harvester object
            2. Camera object

        Two variables:
            1. Camera's height (pixels)
            2. Camera's width (pixels)

    """

    camera = None

    # Setup Harvester
    # Create harvester object as h
    h = Harvester()

    # Give path to GENTL producer
    cti_file = cti_filepath

    # Add GENTL producer to Harvester object
    h.add_file(cti_file)

    # Update Harvester object
    h.update()

    # Print device list to make sure camera is present
    print("Connected to Camera: \n", h.device_info_list)

    # Grab Camera, Change Settings
    # Create image_acquirer object for Harvester, grab first (only) device
    camera = h.create_image_acquirer(0)

    # Gather node map to camera properties
    n = camera.remote_device.node_map

    # Set and then save camera width and height parameters
    width = n.Width.value  # width = 1280
    height = n.Height.value  # height = 1024

    # Change camera properties to listen for Bruker TTL triggers
    # Record continuously
    n.AcquisitionMode.value = "Continuous"

    # If the behavior only flag is false, enable triggers
    if behavior_flag is False:
        n.TriggerMode.value = "On"

    # If the behavior only flag is true, disable triggers
    else:
        n.TriggerMode.value = "Off"

    # Trigger camera on rising edge of input signal
    n.TriggerActivation.value = "RisingEdge"

    # Select Line 2 as the Trigger Source and Input Source
    n.TriggerSource.value = "Line2"
    n.LineSelector.value = "Line2"

    # Print in terminal which acquisition mode is enabled
    print("Acquisition Mode: ", n.AcquisitionMode.value)

    # Start the acquisition, return camera and harvester for buffer
    print("Starting Acquisition")
    camera.start_acquisition()

    # Return Harvester, camera, and frame dimensions
    return h, camera, width, height


# -----------------------------------------------------------------------------
# Capture Camera Recording
# -----------------------------------------------------------------------------


def capture_recording(number_frames, video_list, behavior_flag=False):
    """
    Capture frames generated by camera object, display them in recording mode,
    and write frames to .avi file.

    Takes values from init_camera_recording() to capture images delivered by
    camera buffer, reshapes the image to appropriate height and width, displays
    the image to an opencv window, and writes the image to a .avi file.
    When the camera acquires the specified number of frames for an experiment,
    the window closes, the camera object is destroyed, and the video is written
    to disk.

    Args:
        number_frames:
            Number of frames specified to collect for the video recording
        video_list:
            List of video parameters including filename, path values,
        behavior_flag:
            Flag obtained from bruker_control.py argparser.  If True,
            a continous recording is obtained without relying on TTL triggers
            fromt the microscope. If False, the recording will use TTL
            triggers from the microscope.

    Returns:
        A list of dropped frames from the recording to be appended to the
        config file.
    """

    # Assign video name as the config_filename for readability
    video_name = video_list[1] + ".avi"

    # Give basepath for video using supplied project name
    video_basepath = "E:/studies/" + video_list[0] + "/video/"

    # Create full video path
    video_fullpath = video_basepath + video_name

    # Define number of frames to record
    # TODO: Number of frames: Make this an input/from setup
    num_frames = number_frames

    # Define video codec for writing images
    fourcc = cv2.VideoWriter_fourcc(*'DIVX')

    # Start the Camera
    h, camera, width, height = init_camera_recording(behavior_flag)

    # Write file to disk
    # Create VideoWriter object: file, codec, framerate, dims, color value
    out = cv2.VideoWriter(video_fullpath, fourcc, 30, (width, height),
                          isColor=False)

    # Tell user Video Writer weas created successfully
    print("VideoWriter created")

    dropped_frame_list = []
    frame_number = 1
    for i in range(num_frames):

        # Introduce try/except block in case of dropped frames
        # More elegant solution for packet loss is necessary...
        try:

            # Use with statement to acquire buffer, payload, an data
            # Payload is 1D numpy array, RESHAPE WITH HEIGHT THEN WIDTH
            # Numpy is backwards, reshaping as heightxwidth writes correctly
            with camera.fetch_buffer() as buffer:

                # Define frame content with buffer.payload
                content = buffer.payload.components[0].data.reshape(height,
                                                                    width)

                # Debugging statment, print content shape and frame number
                out.write(content)
                # print(content.shape)
                cv2.imshow("Live", content)
                cv2.waitKey(1)
                # frame_number_list.append(frame_number)
                # print(frame_number)
                frame_number += 1

        # TODO What is exception for dropped frame? How to make an exception?
        # Except block for if/when frames are dropped
        except:
            dropped_frame_list.append(frame_number)
            print("Frame Dropped/Packet Loss", frame_number)
            frame_number += 1
            pass

    # Once recording is done, let user know
    print("Video Complete")

    # Release VideoWriter object
    out.release()

    # Destroy camera window
    cv2.destroyAllWindows()

    # Shutdown the camera
    shutdown_camera(camera, h)

    return dropped_frame_list

# -----------------------------------------------------------------------------
# Shutdown Camera
# -----------------------------------------------------------------------------


def shutdown_camera(camera, harvester):
    """
    Deactivates and resets both harvester and camera after acquisition.

    Turns off camera, resets its configuration values, and resets the harvester
    object once acquisition is done.

    Args:
        camera:
            Harverster camera object
        harvester:
            Haverster object

    Returns:
        None
    """
    # Stop the camera's acquisition
    print("Stopping Acquisition")
    camera.stop_acquisition()

    # Destroy the camera object, release the resource
    print("Camera Destroyed")
    camera.destroy()

    # Reset Harvester object
    print("Resetting Harvester")
    camera.reset()
